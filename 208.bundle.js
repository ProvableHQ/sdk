(self.webpackChunkaleo_website=self.webpackChunkaleo_website||[]).push([[208],{1208:(r,e,t)=>{t.a(r,(async(r,i)=>{try{t.d(e,{AleoKeyProvider:()=>y,AleoKeyProviderParams:()=>d,PrivateKey:()=>a._q,ProgramManager:()=>p,ProgramManagerBase:()=>a.L,initThreadPool:()=>a.CK,verifyFunctionExecution:()=>a.hz});var a=t(6511),n=r([a]);a=(n.then?(await n)():n)[0];async function o(r,e){const t=await fetch(r,e);if(!t.ok)throw new Error(t.status+" could not get URL "+r);return t}async function s(r,e){e.method="POST";const t=await fetch(r,e);if(!t.ok)throw new Error(t.status+" could not post URL "+r);return t}class f{host;headers;account;constructor(r,e){this.host=r+"/testnet",e&&e.headers?this.headers=e.headers:this.headers={"X-Aleo-SDK-Version":"0.6.9"}}setAccount(r){this.account=r}getAccount(){return this.account}setHost(r){this.host=r+"/testnet"}async fetchData(r="/"){try{const e=await o(this.host+r,{headers:this.headers});return await e.json()}catch(r){throw new Error("Error fetching data.")}}async findUnspentRecords(r,e,t,i,n,o){if(o=o||[],r<0)throw new Error("Start height must be greater than or equal to 0");const s=new Array;let c,h,u,l,f=0,d=BigInt(0);if(void 0===t){if(void 0===this.account)throw new Error("Private key must be specified in an argument to findOwnedRecords or set in the AleoNetworkClient");u=this.account._privateKey}else try{u=t instanceof a._q?t:a._q.from_string(t)}catch(r){throw new Error("Error parsing private key provided.")}const y=u.to_view_key();try{const r=await this.getLatestHeight();if("number"!=typeof r)throw new Error("Error fetching latest block height.");l=r}catch(r){throw new Error("Error fetching latest block height.")}if(h="number"==typeof e&&e<=l?e:l,r>h)throw new Error("Start height must be less than or equal to end height.");for(;h>r;){c=h-50,c<r&&(c=r);try{const r=await this.getBlockRange(c,h);if(h=c,!(r instanceof Error))for(let e=0;e<r.length;e++){const t=r[e].transactions;if(void 0!==t)for(let r=0;r<t.length;r++){const e=t[r];if("execute"==e.type){const r=e.transaction;if(r.execution&&void 0!==r.execution.transitions)for(let e=0;e<r.execution.transitions.length;e++){const t=r.execution.transitions[e];if("credits.aleo"===t.program&&void 0!==t.outputs)for(let r=0;r<t.outputs.length;r++){const e=t.outputs[r];if("record"===e.type)try{const r=a.fW.fromString(e.value);if(r.isOwner(y)){const e=r.decrypt(y),t=e.nonce();if(o.includes(t))continue;const a=e.serialNumberString(u,"credits.aleo","credits");try{await this.getTransitionId(a)}catch(r){if(!i&&(s.push(e),"number"==typeof n&&(d+=e.microcredits(),d>=BigInt(n))))return s;if(void 0!==i&&i.length>0){let r=0;if(e.microcredits()>i[r]){if(r+=1,s.push(e),"number"==typeof n&&(d+=e.microcredits(),d>=BigInt(n)))return s;if(s.length>=i.length)return s}}}}}catch(r){}}}}}}}catch(r){if(console.warn("Error fetching blocks in range: "+c.toString()+"-"+h.toString()),console.warn("Error: ",r),f+=1,f>10)return console.warn("10 failures fetching records reached. Returning records fetched so far"),s}}return s}async getBlock(r){try{return await this.fetchData("/block/"+r)}catch(r){throw new Error("Error fetching block.")}}async getBlockRange(r,e){try{return await this.fetchData("/blocks?start="+r+"&end="+e)}catch(t){throw new Error("Error fetching blocks between "+r+" and "+e+".")}}async getDeploymentTransactionIDForProgram(r){r instanceof a.$r&&(r=r.toString());try{return(await this.fetchData("/find/transactionID/deployment/"+r)).replace('"',"")}catch(r){throw new Error("Error fetching deployment transaction for program.")}}async getDeploymentTransactionForProgram(r){try{const e=await this.getDeploymentTransactionIDForProgram(r);return await this.getTransaction(e)}catch(r){throw new Error("Error fetching deployment transaction for program.")}}async getLatestBlock(){try{return await this.fetchData("/latest/block")}catch(r){throw new Error("Error fetching latest block.")}}async getLatestCommittee(){try{return await this.fetchData("/committee/latest")}catch(r){throw new Error("Error fetching latest block.")}}async getLatestHeight(){try{return await this.fetchData("/latest/height")}catch(r){throw new Error("Error fetching latest height.")}}async getProgram(r){try{return await this.fetchData("/program/"+r)}catch(r){throw new Error("Error fetching program")}}async getProgramObject(r){try{return a.$r.fromString(r)}catch(e){try{return a.$r.fromString(await this.getProgram(r))}catch(e){throw new Error(`${r} is neither a program name or a valid program`)}}}async getProgramImports(r){try{const e={},t=(r instanceof a.$r?r:await this.getProgramObject(r)).getImports();for(let r=0;r<t.length;r++){const i=t[r];if(!e.hasOwnProperty(i)){const r=await this.getProgram(i),t=await this.getProgramImports(i);for(const r in t)e.hasOwnProperty(r)||(e[r]=t[r]);e[i]=r}}return e}catch(r){throw l("Error fetching program imports: "+r)}}async getProgramImportNames(r){try{return(r instanceof a.$r?r:await this.getProgramObject(r)).getImports()}catch(r){throw new Error("Error fetching program imports with error: "+r)}}async getProgramMappingNames(r){try{return await this.fetchData("/program/"+r+"/mappings")}catch(r){throw new Error("Error fetching program mappings - ensure the program exists on chain before trying again")}}async getProgramMappingValue(r,e,t){try{return await this.fetchData("/program/"+r+"/mapping/"+e+"/"+t)}catch(r){throw new Error("Error fetching mapping value - ensure the mapping exists and the key is correct")}}async getStateRoot(){try{return await this.fetchData("/latest/stateRoot")}catch(r){throw new Error("Error fetching Aleo state root")}}async getTransaction(r){try{return await this.fetchData("/transaction/"+r)}catch(r){throw new Error("Error fetching transaction.")}}async getTransactions(r){try{return await this.fetchData("/block/"+r.toString()+"/transactions")}catch(r){throw new Error("Error fetching transactions.")}}async getTransactionsInMempool(){try{return await this.fetchData("/memoryPool/transactions")}catch(r){throw new Error("Error fetching transactions from mempool.")}}async getTransitionId(r){try{return await this.fetchData("/find/transitionID/"+r)}catch(r){throw new Error("Error fetching transition ID.")}}async submitTransaction(r){const e=r instanceof a.YW?r.toString():r;try{const r=await s(this.host+"/transaction/broadcast",{body:e,headers:Object.assign({},this.headers,{"Content-Type":"application/json"})});try{return await r.json()}catch(r){throw new Error(`Error posting transaction. Aleo network response: ${r.message}`)}}catch(r){throw new Error(`Error posting transaction: No response received: ${r.message}`)}}}class d{proverUri;verifierUri;cacheKey;constructor(r){this.proverUri=r.proverUri,this.verifierUri=r.verifierUri,this.cacheKey=r.cacheKey}}class y{cache;cacheOption;keyUris;async fetchBytes(r="/"){try{const e=await o(r),t=await e.arrayBuffer();return new Uint8Array(t)}catch(r){throw new Error("Error fetching data."+r)}}constructor(){this.keyUris=v,this.cache=new Map,this.cacheOption=!1}useCache(r){this.cacheOption=r}clearCache(){this.cache.clear()}cacheKeys(r,e){const[t,i]=e;this.cache.set(r,[t.toBytes(),i.toBytes()])}containsKeys(r){return this.cache.has(r)}deleteKeys(r){return this.cache.delete(r)}getKeys(r){if(console.debug(`Checking if key exists in cache. KeyId: ${r}`),this.cache.has(r)){const[e,t]=this.cache.get(r);return[a.zW.fromBytes(e),a.XV.fromBytes(t)]}return new Error("Key not found in cache.")}async functionKeys(r){if(r){let e,t,i;if("proverUri"in r&&"string"==typeof r.proverUri&&(e=r.proverUri),"verifierUri"in r&&"string"==typeof r.verifierUri&&(t=r.verifierUri),"cacheKey"in r&&"string"==typeof r.cacheKey&&(i=r.cacheKey),e&&t)return await this.fetchKeys(e,t,i);if(i)return this.getKeys(i)}throw Error("Invalid parameters provided, must provide either a cacheKey and/or a proverUrl and a verifierUrl")}async fetchKeys(r,e,t){try{if(this.cacheOption){t||(t=r);const i=this.cache.get(t);if(void 0!==i)return[a.zW.fromBytes(i[0]),a.XV.fromBytes(i[1])];{console.debug("Fetching proving keys from url "+r);const i=a.zW.fromBytes(await this.fetchBytes(r));console.debug("Fetching verifying keys "+e);const n=await this.getVerifyingKey(e);return this.cache.set(t,[i.toBytes(),n.toBytes()]),[i,n]}}{const t=a.zW.fromBytes(await this.fetchBytes(r));return[t,await this.getVerifyingKey(e)]}}catch(t){throw new Error(`Error: ${t} fetching fee proving and verifying keys from ${r} and ${e}.`)}}bondPublicKeys(){return this.fetchKeys(g.bond_public.prover,g.bond_public.verifier,g.bond_public.locator)}bondValidatorKeys(){return this.fetchKeys(g.bond_validator.prover,g.bond_validator.verifier,g.bond_validator.locator)}claimUnbondPublicKeys(){return this.fetchKeys(g.claim_unbond_public.prover,g.claim_unbond_public.verifier,g.claim_unbond_public.locator)}async transferKeys(r){if(m.has(r))return await this.fetchKeys(g.transfer_private.prover,g.transfer_private.verifier,g.transfer_private.locator);if(_.has(r))return await this.fetchKeys(g.transfer_private_to_public.prover,g.transfer_private_to_public.verifier,g.transfer_private_to_public.locator);if(P.has(r))return await this.fetchKeys(g.transfer_public.prover,g.transfer_public.verifier,g.transfer_public.locator);if(k.has(r))return await this.fetchKeys(g.transfer_public_as_signer.prover,g.transfer_public_as_signer.verifier,g.transfer_public_as_signer.locator);if(K.has(r))return await this.fetchKeys(g.transfer_public_to_private.prover,g.transfer_public_to_private.verifier,g.transfer_public_to_private.locator);throw new Error("Invalid visibility type")}async joinKeys(){return await this.fetchKeys(g.join.prover,g.join.verifier,g.join.locator)}async splitKeys(){return await this.fetchKeys(g.split.prover,g.split.verifier,g.split.locator)}async feePrivateKeys(){return await this.fetchKeys(g.fee_private.prover,g.fee_private.verifier,g.fee_private.locator)}async feePublicKeys(){return await this.fetchKeys(g.fee_public.prover,g.fee_public.verifier,g.fee_public.locator)}async getVerifyingKey(r){switch(r){case g.bond_public.verifier:return g.bond_public.verifyingKey();case g.bond_validator.verifier:return g.bond_validator.verifyingKey();case g.claim_unbond_public.verifier:return g.claim_unbond_public.verifyingKey();case g.fee_private.verifier:return g.fee_private.verifyingKey();case g.fee_public.verifier:return g.fee_public.verifyingKey();case g.inclusion.verifier:return g.inclusion.verifyingKey();case g.join.verifier:return g.join.verifyingKey();case g.set_validator_state.verifier:return g.set_validator_state.verifyingKey();case g.split.verifier:return g.split.verifyingKey();case g.transfer_private.verifier:return g.transfer_private.verifyingKey();case g.transfer_private_to_public.verifier:return g.transfer_private_to_public.verifyingKey();case g.transfer_public.verifier:return g.transfer_public.verifyingKey();case g.transfer_public_as_signer.verifier:return g.transfer_public_as_signer.verifyingKey();case g.transfer_public_to_private.verifier:return g.transfer_public_to_private.verifyingKey();case g.unbond_public.verifier:return g.unbond_public.verifyingKey();default:try{const e=await o(r),t=await e.text();return a.XV.fromString(t)}catch(e){try{return a.XV.fromBytes(await this.fetchBytes(r))}catch(r){return new Error("Invalid verifying key. Error: "+r)}}}}unBondPublicKeys(){return this.fetchKeys(g.unbond_public.prover,g.unbond_public.verifier,g.unbond_public.locator)}}class p{account;keyProvider;host;networkClient;recordProvider;constructor(r,e,t){this.host=r||"https://api.explorer.aleo.org/v1",this.networkClient=new f(this.host),this.keyProvider=e||new y,this.recordProvider=t}setAccount(r){this.account=r}setKeyProvider(r){this.keyProvider=r}setHost(r){this.host=r,this.networkClient.setHost(r)}setRecordProvider(r){this.recordProvider=r}async deploy(r,e,t,i,n,o){try{const e=a.$r.fromString(r);let t;try{t=await this.networkClient.getProgram(e.id())}catch(r){console.log(`Program ${e.id()} does not exist on the network, deploying...`)}if("string"==typeof t)throw`Program ${e.id()} already exists on the network, please rename your program`}catch(r){throw l(`Error validating program: ${r}`)}let s,c=o;if(void 0===o&&void 0!==this.account&&(c=this.account.privateKey()),void 0===c)throw"No private key provided and no private key set in the ProgramManager";try{n=t?await this.getCreditsRecord(e,[],n,i):void 0}catch(r){throw l(`Error finding fee record. Record finder response: '${r}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}try{s=t?await this.keyProvider.feePrivateKeys():await this.keyProvider.feePublicKeys()}catch(r){throw l(`Error finding fee keys. Key finder response: '${r}'. Please ensure your key provider is configured correctly.`)}const[h,u]=s;let f;try{f=await this.networkClient.getProgramImports(r)}catch(r){throw l(`Error finding program imports. Network response: '${r}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`)}const d=await a.L.buildDeploymentTransaction(c,r,e,n,this.host,f,h,u);return await this.networkClient.submitTransaction(d)}async buildExecutionTransaction(r){const{programName:e,functionName:t,fee:i,privateFee:n,inputs:o,recordSearchParams:s,keySearchParams:c,privateKey:h,offlineQuery:u}=r;let f=r.feeRecord,d=r.provingKey,y=r.verifyingKey,p=r.program,v=r.imports;if(void 0===p)try{p=await this.networkClient.getProgram(e)}catch(r){throw l(`Error finding ${e}. Network response: '${r}'. Please ensure you're connected to a valid Aleo network the program is deployed to the network.`)}else p instanceof a.$r&&(p=p.toString());let g,w=h;if(void 0===h&&void 0!==this.account&&(w=this.account.privateKey()),void 0===w)throw"No private key provided and no private key set in the ProgramManager";try{f=n?await this.getCreditsRecord(i,[],f,s):void 0}catch(r){throw l(`Error finding fee record. Record finder response: '${r}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}try{g=n?await this.keyProvider.feePrivateKeys():await this.keyProvider.feePublicKeys()}catch(r){throw l(`Error finding fee keys. Key finder response: '${r}'. Please ensure your key provider is configured correctly.`)}const[b,m]=g;if(!d||!y)try{[d,y]=await this.keyProvider.functionKeys(c)}catch(r){console.log(`Function keys not found. Key finder response: '${r}'. The function keys will be synthesized`)}if(a.$r.fromString(p).getImports().length>0&&!v)try{v=await this.networkClient.getProgramImports(e)}catch(r){throw l(`Error finding program imports. Network response: '${r}'. Please ensure you're connected to a valid Aleo network and the program is deployed to the network.`)}return await a.L.buildExecutionTransaction(w,p,t,o,i,f,this.host,v,d,y,b,m,u)}async execute(r){const e=await this.buildExecutionTransaction(r);return await this.networkClient.submitTransaction(e)}async run(r,e,t,i,n,o,s,c,h,u){let l=h;if(void 0===h&&void 0!==this.account&&(l=this.account.privateKey()),void 0===l)throw"No private key provided and no private key set in the ProgramManager";if(!s||!c)try{[s,c]=await this.keyProvider.functionKeys(o)}catch(r){console.log(`Function keys not found. Key finder response: '${r}'. The function keys will be synthesized`)}return console.log("Running program offline"),console.log("Proving key: ",s),console.log("Verifying key: ",c),a.L.executeFunctionOffline(l,r,e,t,i,!1,n,s,c,this.host,u)}async join(r,e,t,i,n,o,s,c){let h,u,f=s;if(void 0===s&&void 0!==this.account&&(f=this.account.privateKey()),void 0===f)throw"No private key provided and no private key set in the ProgramManager";try{h=i?await this.keyProvider.feePrivateKeys():await this.keyProvider.feePublicKeys(),u=await this.keyProvider.joinKeys()}catch(r){throw l(`Error finding fee keys. Key finder response: '${r}'. Please ensure your key provider is configured correctly.`)}const[d,y]=h,[p,v]=u;try{o=i?await this.getCreditsRecord(t,[],o,n):void 0}catch(r){throw l(`Error finding fee record. Record finder response: '${r}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}try{r=r instanceof a.PD?r:a.PD.fromString(r),e=e instanceof a.PD?e:a.PD.fromString(e)}catch(r){throw l("Records provided are not valid. Please ensure they are valid plaintext records.")}const g=await a.L.buildJoinTransaction(f,r,e,t,o,this.host,p,v,d,y,c);return await this.networkClient.submitTransaction(g)}async split(r,e,t,i){let n,o=t;if(void 0===o&&void 0!==this.account&&(o=this.account.privateKey()),void 0===o)throw"No private key provided and no private key set in the ProgramManager";try{n=await this.keyProvider.splitKeys()}catch(r){throw l(`Error finding fee keys. Key finder response: '${r}'. Please ensure your key provider is configured correctly.`)}const[s,c]=n;try{e=e instanceof a.PD?e:a.PD.fromString(e)}catch(r){throw l("Record provided is not valid. Please ensure it is a valid plaintext record.")}const h=await a.L.buildSplitTransaction(o,r,e,this.host,s,c,i);return await this.networkClient.submitTransaction(h)}async synthesizeKeys(r,e,t,i){let n,o=i;void 0===o&&(o=void 0!==this.account?this.account.privateKey():new a._q);try{n=await this.networkClient.getProgramImports(r);const i=await a.L.synthesizeKeyPair(o,r,e,t,n);return[i.provingKey(),i.verifyingKey()]}catch(r){throw l(`Could not synthesize keys - error ${r}. Please ensure the program is valid and the inputs are correct.`)}}async buildTransferTransaction(r,e,t,i,n,o,s,u,f,d,y){t=h(t);let p,v,g=d;if(void 0===g&&void 0!==this.account&&(g=this.account.privateKey()),void 0===g)throw"No private key provided and no private key set in the ProgramManager";try{p=n?await this.keyProvider.feePrivateKeys():await this.keyProvider.feePublicKeys(),v=await this.keyProvider.transferKeys(t)}catch(r){throw l(`Error finding fee keys. Key finder response: '${r}'. Please ensure your key provider is configured correctly.`)}const[w,b]=p,[m,_]=v;try{const r=[];c(t)?(u=await this.getCreditsRecord(i,[],u,s),r.push(u.nonce())):u=void 0,f=n?await this.getCreditsRecord(i,r,f,s):void 0}catch(r){throw l(`Error finding fee record. Record finder response: '${r}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}return await a.L.buildTransferTransaction(g,r,e,t,o,u,i,f,this.host,m,_,w,b,y)}async buildTransferPublicTransaction(r,e,t,i,a,n){return this.buildTransferTransaction(r,t,"public",i,!1,e,void 0,void 0,void 0,a,n)}async buildTransferPublicAsSignerTransaction(r,e,t,i,a){return this.buildTransferTransaction(r,e,"public",t,!1,void 0,void 0,void 0,void 0,i,a)}async transfer(r,e,t,i,a,n,o,s,c,h,u){const l=await this.buildTransferTransaction(r,e,t,i,a,n,o,s,c,h,u);return await this.networkClient.submitTransaction(l)}async buildBondPublicTransaction(r,e,t,i,a={}){const n=Math.trunc(1e6*i),{programName:o="credits.aleo",functionName:s="bond_public",fee:c=a.fee||.86,privateFee:h=!1,inputs:u=[r,e,t,`${n.toString()}u64`],keySearchParams:l=new d({proverUri:g.bond_public.prover,verifierUri:g.bond_public.verifier,cacheKey:"credits.aleo/bond_public"}),program:f=this.creditsProgram(),...y}=a,p={programName:o,functionName:s,fee:c,privateFee:h,inputs:u,keySearchParams:l,...y};return await this.buildExecutionTransaction(p)}async bondPublic(r,e,t,i,a={}){const n=await this.buildBondPublicTransaction(r,e,t,i,a);return await this.networkClient.submitTransaction(n)}async buildBondValidatorTransaction(r,e,t,i,a={}){const n=Math.trunc(1e6*t),o=Math.trunc(i),{programName:s="credits.aleo",functionName:c="bond_validator",fee:h=a.fee||.86,privateFee:u=!1,inputs:l=[r,e,`${n.toString()}u64`,`${o.toString()}u8`],keySearchParams:f=new d({proverUri:g.bond_validator.prover,verifierUri:g.bond_validator.verifier,cacheKey:"credits.aleo/bond_validator"}),program:y=this.creditsProgram(),...p}=a,v={programName:s,functionName:c,fee:h,privateFee:u,inputs:l,keySearchParams:f,...p};return await this.buildExecutionTransaction(v)}async bondValidator(r,e,t,i,a={}){const n=await this.buildBondValidatorTransaction(r,e,t,i,a);return await this.networkClient.submitTransaction(n)}async buildUnbondPublicTransaction(r,e,t={}){const i=Math.trunc(1e6*e),{programName:a="credits.aleo",functionName:n="unbond_public",fee:o=t.fee||1.3,privateFee:s=!1,inputs:c=[r,`${i.toString()}u64`],keySearchParams:h=new d({proverUri:g.unbond_public.prover,verifierUri:g.unbond_public.verifier,cacheKey:"credits.aleo/unbond_public"}),program:u=this.creditsProgram(),...l}=t,f={programName:a,functionName:n,fee:o,privateFee:s,inputs:c,keySearchParams:h,...l};return this.buildExecutionTransaction(f)}async unbondPublic(r,e,t={}){const i=await this.buildUnbondPublicTransaction(r,e,t);return await this.networkClient.submitTransaction(i)}async buildClaimUnbondPublicTransaction(r,e={}){const{programName:t="credits.aleo",functionName:i="claim_unbond_public",fee:a=e.fee||2,privateFee:n=!1,inputs:o=[r],keySearchParams:s=new d({proverUri:g.claim_unbond_public.prover,verifierUri:g.claim_unbond_public.verifier,cacheKey:"credits.aleo/claim_unbond_public"}),program:c=this.creditsProgram(),...h}=e,u={programName:t,functionName:i,fee:a,privateFee:n,inputs:o,keySearchParams:s,...h};return await this.buildExecutionTransaction(u)}async claimUnbondPublic(r,e={}){const t=await this.buildClaimUnbondPublicTransaction(r,e);return await this.networkClient.submitTransaction(t)}async buildSetValidatorStateTransaction(r,e={}){const{programName:t="credits.aleo",functionName:i="set_validator_state",fee:a=1,privateFee:n=!1,inputs:o=[r.toString()],keySearchParams:s=new d({proverUri:g.set_validator_state.prover,verifierUri:g.set_validator_state.verifier,cacheKey:"credits.aleo/set_validator_state"}),...c}=e,h={programName:t,functionName:i,fee:a,privateFee:n,inputs:o,keySearchParams:s,...c};return await this.execute(h)}async setValidatorState(r,e={}){const t=await this.buildSetValidatorStateTransaction(r,e);return this.networkClient.submitTransaction(t)}verifyExecution(r){try{const e=r.getExecution(),t=r.getFunctionId(),i=r.getProgram(),n=r.getVerifyingKey();return(0,a.hz)(e,n,i,t)}catch(r){return console.warn("The execution was not found in the response, cannot verify the execution"),!1}}createProgramFromSource(r){return a.$r.fromString(r)}creditsProgram(){return a.$r.getCreditsProgram()}verifyProgram(r){try{return a.$r.fromString(r),!0}catch(r){return!1}}async getCreditsRecord(r,e,t,i){try{return t instanceof a.PD?t:a.PD.fromString(t)}catch(t){try{const t=this.recordProvider;return await t.findCreditsRecord(r,!0,e,i)}catch(r){throw l(`Error finding fee record. Record finder response: '${r}'. Please ensure you're connected to a valid Aleo network and a record with enough balance exists.`)}}}}function c(r){return w.has(r)}function h(r){return b.has(r)?r:l(`Invalid transfer type '${r}'. Valid transfer types are 'private', 'privateToPublic', 'public', and 'publicToPrivate'.`)}const v=a.SF.baseUrl();function u(r){const e=a.XV[r.verifyingKey];if(!e)throw new Error("Invalid method name: "+r.verifyingKey);return{locator:r.locator,prover:r.prover,verifier:r.verifier,verifyingKey:e}}const g={bond_public:u(a.SF.bond_public()),bond_validator:u(a.SF.bond_validator()),claim_unbond_public:u(a.SF.claim_unbond_public()),fee_private:u(a.SF.fee_private()),fee_public:u(a.SF.fee_public()),inclusion:u(a.SF.inclusion()),join:u(a.SF.join()),set_validator_state:u(a.SF.set_validator_state()),split:u(a.SF.split()),transfer_private:u(a.SF.transfer_private()),transfer_private_to_public:u(a.SF.transfer_private_to_public()),transfer_public:u(a.SF.transfer_public()),transfer_public_as_signer:u(a.SF.transfer_public_as_signer()),transfer_public_to_private:u(a.SF.transfer_public_to_private()),unbond_public:u(a.SF.unbond_public())},w=new Set(["transfer_private","private","transferPrivate","transfer_private_to_public","privateToPublic","transferPrivateToPublic"]),b=new Set(["transfer_private","private","transferPrivate","transfer_private_to_public","privateToPublic","transferPrivateToPublic","transfer_public","transfer_public_as_signer","public","public_as_signer","transferPublic","transferPublicAsSigner","transfer_public_to_private","publicToPrivate","publicAsSigner","transferPublicToPrivate"]),m=new Set(["private","transfer_private","transferPrivate"]),_=new Set(["private_to_public","privateToPublic","transfer_private_to_public","transferPrivateToPublic"]),P=new Set(["public","transfer_public","transferPublic"]),k=new Set(["public_as_signer","transfer_public_as_signer","transferPublicAsSigner"]),K=new Set(["public_to_private","publicToPrivate","transfer_public_to_private","transferPublicToPrivate"]);function l(r){throw console.error(r),r}i()}catch(E){i(E)}}))}}]);
//# sourceMappingURL=208.bundle.js.map